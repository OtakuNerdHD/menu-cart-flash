Hook de sessão (crie src/hooks/useSingleSession.ts)

import { useEffect, useRef } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useMultiTenant } from '@/context/MultiTenantContext';

const KEY = (scope: string) => `sess_${scope}`;

function currentScope(subdomain?: string | null) {
  return subdomain && subdomain.trim() !== '' ? subdomain.trim() : 'master';
}

export function useSingleSession(roleAtLogin: string | null) {
  const { subdomain, currentTenantRole } = useMultiTenant();
  const scope = currentScope(subdomain);
  const sessionIdRef = useRef<string | null>(null);

  // cria sessão ao montar (se já logado e tiver role)
  useEffect(() => {
    // precisa de papel resolvido por tenant
    if (!roleAtLogin && !currentTenantRole) return;

    const role = (roleAtLogin ?? currentTenantRole ?? 'cliente').toLowerCase().trim();
    const prev = localStorage.getItem(KEY(scope));
    sessionIdRef.current = prev || null;

    const start = async () => {
      try {
        // sempre cria nova sessão e mata a antiga no mesmo escopo
        const { data, error } = await supabase.rpc('app.start_session', {
          p_role_at_login: role,
          p_fingerprint: undefined,
          p_user_agent: navigator.userAgent,
          p_ip: null
        } as any);
        if (error) throw error;
        const newId = (data as string) || null;
        sessionIdRef.current = newId;
        if (newId) localStorage.setItem(KEY(scope), newId);
      } catch (e) {
        console.error('start_session error', e);
      }
    };

    // se não houver sessionId local, cria
    if (!prev) start();

    // heartbeat: a cada 5 minutos
    const iv = setInterval(async () => {
      const sid = sessionIdRef.current;
      if (!sid) return;
      try {
        await supabase.rpc('app.touch_session', { p_session_id: sid } as any);
      } catch (e) {
        console.warn('touch_session error', e);
      }
    }, 5 * 60 * 1000);

    return () => clearInterval(iv);
    // role e scope determinam a sessão
  }, [roleAtLogin, currentTenantRole, scope]);

  // helper logout
  const endSession = async () => {
    try {
      const sid = sessionIdRef.current || localStorage.getItem(KEY(scope));
      if (sid) {
        await supabase.rpc('app.end_session', { p_session_id: sid } as any);
      }
    } catch {}
    localStorage.removeItem(KEY(scope));
    sessionIdRef.current = null;
  };

  return { endSession };
}

Onde chamar

Após login bem-sucedido e depois de resolver o contexto do tenant/role (você já faz isso para guards):

No seu AuthContext ou onde já dispara o “pós-login”, chame:

const { endSession } = useSingleSession(null); // ou passe role se já tiver


Como o hook lê currentTenantRole do MultiTenantContext, ele cria/toca sessão no momento certo.

No logout:

Chame endSession() antes/ao mesmo tempo do seu fluxo de signOut.

Dica: se quiser que toda página protegida tenha batida de sessão, use o hook no seu layout root de instância (ex.: AppLayout), que só monta para logados.

3) Rollout (seguro, sem quebrar pilar)

Aplicar migration (não muda nada de RLS v2/isolamentos).

Deploy do frontend com o hook sem bloquear nada (apenas criando/tocando sessão).

Validar:

Logar com o mesmo usuário em 2 navegadores no mesmo tenant: o segundo login desloga (revoga) a sessão antiga silenciosamente.

Trocar de tenant: cada tenant tem 1 sessão própria (escopo separado).

Master (app.delliapp.com.br): tem escopo próprio (independente dos tenants).

(Opcional) Depois crio uma página no Dashboard SAAS para listar e encerrar sessões por tenant (usando service_role / RPC específica).